---
title: review JVM
date: 2018-07-22 21:04:35
tags: ['Java','JVM']
---

复习下关于JVM的知识~~~



<!--more-->

##介绍下Java内存区域（运行时数据区）。

JVM运行时数据区分为方法区、堆内存、虚拟机栈、本地方法栈、程序计数器这五个部分。方法区和堆内存是线程共享的，其他三个区域是线程私有的，其中只有程序计数器没有规定OOM的异常。

- 方法区一般存放着已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码数据等。
- 堆内存一般用于存储实例化后的对象，通常来说又分为新生代和老年代。新生代又分为Eden区和survivor区，他们的大小比例默认为8：2，可以通过-XX:survivorRatio来自定义。对象一般都是在新生代分配内存空间，而老年代一般存放着长期存活或者占用内存较大的对象。
- 虚拟机栈通常存放着指向实例对象的引用、局部变量、方法返回地址、动态链接等信息，其生命周期和线程相同。如果栈请求的深度超过了虚拟机所允许的最大深度，此时JVM会抛出StackOverflowError；如果扩展时无法分配到足够的内存，会抛出OOM
- 本地方法栈和虚拟机栈类似，不过本地方法栈是为JVM执行本地方法服务的，该区域也会抛出栈溢出和内存溢出的异常。
- 程序计数器的作用是为了线程切换后能够恢复到正确的执行位置，不过如果执行的是native方法，对应的程序计数器是为空的



## 对象的访问定位的两种方式。

1. **通过句柄访问，句柄中存储着对象实例数据和类型数据的地址，此时堆内存中需要维护一个句柄池**

使用句柄最大的好处就是移动对象时，reference不需要改变， 改变的只是句柄中的对象地址；

2. 通过指针访问，此时引用中存储的就是对象的地址

而指针的最大好处就是速度更快



## 如何判断对象是否死亡（两种方法）。

1. 引用计数法。

   引用计数法简单高效，当一个对象被引用时其引用计数器就+1，但是这不能解决循环引用的问题。比如类A中的字段引用了类B，类B中也有个字段引用了类A，那么这两个类的对象就永远不会被回收。

2. 可达性分析，也就是分析GC Roots的引用链

   如果对象在GC Roots中不可达、没有引用链，那么说明这个对象是不可用的，可以被垃圾回收的。

   **可做GC Roots的对象**

   - 虚拟机栈中所引用的对象
   - 本地方法栈中所引用的对象
   - 类中的静态属性所引用的对象
   - 方法区常量引用的对象

   

## 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。

1. 强引用：一般是new出来对象的引用，只要存在，就不会被回收

2. 软引用：一般是用来描述可用但又不是必须的对象

3. 弱引用：用来描述非必须的对象，会在垃圾回收的被回收

4. 虚引用：是一种最弱的引用关系，唯一的目的是让这个对象在垃圾回收的时候收到一个系统通知

    

## 垃圾收集有哪些算法，各自的特点？

垃圾回收目前有四种算法分别为标记-清除、复制算法、标记-整理、分代收集算法

1. 标记-清理：存在效率问题和空间问题，清理完后内存中会产生大量不连续的空间碎片，影响下次对象的分配，可能导致提前触发GC
2. 复制算法：实现简单，效率高效，但可能会造成内存空间的浪费
3. 标记-整理：每次标记完可回收对象，让**存活的对象向一端移动**，然后直接清理掉边界以外的内存。这个算法就解决了标记-清理算法的空间问题
4. 分代收集：根据各自区域的特点使用不同的回收算法。如年轻代，对象一般朝生夕死，所以会采用复制算法，而老年代对象存活时间较久，一般采用标记-整理算法，这样也能保证老年代中有连续较大的内存空间，方便分配担保



## HotSpot为什么要分为新生代和老年代？

为了方便垃圾回收时使用对应的回收算法。年轻代中对象一般刚创建后就会被回收，此时采用复制算法只需要复制少量对象，效率高，但是这并不适用老年代中存活交久的对象，当复制较多对象时，复制算法的效率就会很低，此时采用标记-整理的算法更加适合老年代。



## 常见的垃圾回收器有那些？

1. Serial串行收集器：这是一个单进程的、适用于新生代的收集器，采用复制算法，每次回收的时候需要暂停其他的工作线程，也就是需要 STOP THE WORLD。
2. ParNew收集器：是Serial收集器的多线程版本，也是采用复制算法，目前只有他能与CMS收集器一起工作
3. Parallel Scavenge收集器：是一个并行的、新生代的收集器，采用复制算法，他的特点是达到一个可控制的吞吐量
4. CMS收集器：是一款真正意思上的并行的、老年代的收集器，采用了标记-清理算法。
5. Serial Old 收集器：是Serial收集器的老年代版本，采用标记-整理算法。
6. Parallel Old收集器：是Parallel Scavenge的老年代版本，采用标记-整理算法。
7. G1收集器：



##  介绍一下CMS,G1收集器。

*CMS*

是一款真正意思上的并行的、老年代的收集器，特点是并发收集、低停顿。采用了标记-清理算法。收集分为四个过程

1. 初始标记：标记没有关联在GC Roots引用链上的对象
2. 并发标记：GC Roots Tracing的过程
3. 重新标记：修正并发标记期间用户线程继续运行而导致的标记的变动
4. 并发清理：把标记的对象回收

但是也有三个明显的缺点：

1. 对CPU资源非常敏感
2. 无法处理浮动垃圾
3. 因为基于标记-清理算法，因此会产生大量的不连续的空间。不过可以通过开启一个参数让他在Full GC之前进行一次内存整理



*G1*

[美团技术团队的分析](https://tech.meituan.com/g1.html)

[ifeve解析](http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/)



##  Minor GC和Full GC 有什么不同呢？

- Minor GC是发生在年轻代的GC，发生频率高，回收速度快
- Full GC发生在老年代的GC，发生的时候一般伴随着一次Minor GC，速度较慢，一般是比Minor GC慢十倍



## JVM调优的常见命令行工具有哪些？

Linux：top、iostat、pidstat、uptime

Java自带：jstack、jinfo、jstat



##简单介绍一下Class类文件结构（常量池主要存放的是那两大常量？Class文件的继承关系是如何确定的？字段表、方法表、属性表主要包含那些信息？）

1. 常量池一般存放符号引用和字面量
   - 字面量：一般指文本字符串、声明为final的常量

   - 符号引用：
     - 类和接口的全限定名
     - 字段的名称和描述符
     - 方法的名称和描述符

     

2. 类索引、父类索引和接口索引集合确定了Class文件的继承关系

3. - 字段表用于描述类或接口中声明的变量
   - 方法表的结构与字段表一样
   - 属性表包含了类文件或者接口所定义的属性的基本信息



## 简单说说类加载过程，里面执行了哪些操作？

类加载一般分为七个过程：

1. 加载
   - 通过一个类的全限定名来加载对应的二进制流
   - 将这个二进制流代表的静待存储结构转化为方法区的运行时数据结构
   - 在Java堆中生成一个Class对象作为方法区访问这些数据的入口
2. 验证
   - 一般完成四个阶段的验证
     1. 文件格式验证：验证二进制流符合虚拟机的要求，比如前四个字节为cafebaby，第五第六个字节为次版本号，第七第八个字节为主版本号
     2. 元数据验证：就是对类的元数据信息进行语义校验
     3. 字节码验证：对数据流和控制流分析，确保不会危害虚拟机
     4. 符号引用验证：对常量池中的各种符号引用的校验
3. 准备
   - 对类变量设置初始值的过程，这个初始值是数据类型的默认值，而不是为类变量进行初始化。比如public static int a =3，此时准备阶段只是将int值赋值为0
4. 解析
   - 虚拟机将常量池中的符号引用转化为直接引用的过程
     1. 类或接口的解析
     2. 字段解析
     3. 类方法解析
     4. 接口方法解析
5. 初始化
   - 此阶段真正开始执行类中定义的Java代码
6. 使用
7. 卸载



## 对类加载器有了解吗？

类加载器是一个代码模块，他的作用是通过类的全限定名来加载对应类的二进制流。类加载器分为三类：

- 启动类加载器

  加载JAVA_HOME/lib目录下的类

- 扩展类加载器

  加载JAVA_HOME/lib/ext目录下的类

- 应用程序扩展类

  一般用于加载用户路径上所指定的类库

  

## 什么是双亲委派模型？

双亲委派模型就是除了顶层的启动类加载器外，其余的加载器都应当有自己的父类加载器，是一种类加载器的关系模型。



## 双亲委派模型的工作过程以及使用它的好处。

1. 工作过程

   一个类加载器收到类的加载请求，会将请求委托给父类加载器，每层加载器都是如此，直到委托给启动类加载器，如果父类加载器反馈无法加载，那么子加载器才会尝试自己加载

2. 好处

   Java类随着它的类加载器有了一种带优先级的层级关系。比如你自己建了一个Object类与Java自带的Object类重名了，虽然可以正常编译，但是永远无法被加载运行。这样就保证了代码的稳定性。







> *大部分正义感都是虚伪的 聊胜于无   —————————————沃德彭尤·胡某*