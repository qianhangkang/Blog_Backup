---
title: Java内存模型
date: 2019-11-02 14:57:07
tags: ['Java']
---

Java内存模型（Java Memory Model）。

当初曾和Java运行时内存区域混淆了。。。

<!--more-->

# Java内存模型

> Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言如C/C++等 直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另一套平台上并发访问却经常错误，因此在某些场景就必须针对不同的平台来编写程序。
>
> 定义Java内存模型并非一件容易的事情，这个模型必须定义得足够谨慎，才能让Java的并发访问操作不会产生歧义；但是，也必须定义得足够宽松，使得Java虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存去、高速缓存和指令集中某些特有的指令）来获取更好的执行速度。

## 主内存和工作内存

交互图：

![Java内存模型.001.png](https://i.loli.net/2018/08/24/5b7f7665b7e96.png)

Java内存模型规定了所有的变量都存储在主内存中。每个线程拥有自己的工作内存，工作内存用于保存该线程在主内存中使用到的变量的副本拷贝，线程对该变量的操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存的变量，线程之间变量值的传递都需要通过主内存来完成。

## 内存间交互操作

1. lock，作用于主内存中的变量，它会将一个变量标识为一条线成独占的状态
2. unlock，同上，不过它将变量从锁定状态释放出来
3. read，作用于主内存，该操作将主内存中的变量传递到某个Java线程的工作内存中
4. load，作用于工作内存的变量，该操作将read过来的变量赋值给工作内存中的变量
5. use，作用于工作内存的变量，该操作将工作内存中的变量传递给执行引擎使用
6. assign，作用于工作内存的变量，该操作将执行引擎中接受的变量赋值给工作内存中的变量
7. store，作用于工作内存的变量，该操作将工作内存中的变量传递到主内存中
8. write，作用于主内存中的变量，该操作将store过来的变量赋值给主内存中的变量

## volatile变量

volatile变量是Java中的一个关键字，是Java虚拟机提供的最轻量的同步机制。

volatile修饰的变量保证了不同线程对该变量的可见性和有序性（禁止指令重排序），但无法保证该变量的原子性

- 当一个线程对volatile修饰的变量进行读操作的时候，会强制从主内存中read该变量的值，然后load其工作内存中的变量；当进行写操作的时候，会强制将工作内存中的变量store进主内存中，主内存再进行write操作。这样就保证了其他线程对于该变量的可见性。

  从字节码的角度来看，一个被volatile修饰的变量赋值后，编译器会自动执行一个lock的空操作，该空操作会强制本CPU的cache写入主内存中，该写入动作也会导致别的CPU中的cache无效化，这种操作就相当于刚才说的store和write操作

- volatile会禁止指令重排序。普通的变量仅仅保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到结果，但不能保证与程序代码的执行顺序一致。volatile修饰的变量会产生一个内存屏障，就是lock一个空操作，该操作后的指令不能被重排序到该指令之前

## 可见性

可见性是指当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改。

## 有序性

有序性指的是在本线程内观察，所有操作都是有序的；在一个线程中观察另一个线程，所有的操作都是无序的。前半句指的是“线程内表现为串行的寓意”，后半句是指“指令重排序”现象和“工作内存与主内存延迟同步”的现象

## 原子性

Java内存模型直接保证的原子性变量操作包括read、load、use、assign、store、write。原子操作保证了这些操作要么都做了，要么都没做

# 参考资料

《深入理解Java虚拟机》——周志明

http://www.techug.com/post/java-volatile-keyword.html















> *大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某*

